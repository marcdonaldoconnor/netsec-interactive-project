/*

this hole script is generated by grok AI

*/

/**
 * --------------------------------------------------------------
 * localStorage Dictionary Helpers
 * --------------------------------------------------------------
 * All functions work with *plain objects* (no circular refs!).
 * Errors are silently caught – you get a console warning in dev.
 * --------------------------------------------------------------

/**
 * Save an object as JSON under `key`.
 * @param {string} key
 * @param {Object} dict
 */
function saveDict(key, dict) {
  if (typeof key !== 'string' || key === '') {
    console.error('[saveDict] key must be a non-empty string');
    return;
  }
  try {
    const json = JSON.stringify(dict);
    localStorage.setItem(key, json);
  } catch (e) {
    console.warn('[saveDict] Failed to save:', e);
  }
}

/**
 * Load an object from `key`. Returns `defaultDict` on failure.
 * @param {string} key
 * @param {Object} [defaultDict={}]
 * @returns {Object}
 */
function loadDict(key, defaultDict = {}) {
  if (typeof key !== 'string' || key === '') {
    console.error('[loadDict] key must be a non-empty string');
    return defaultDict;
  }
  try {
    const json = localStorage.getItem(key);
    if (json === null) return defaultDict;
    return JSON.parse(json);
  } catch (e) {
    console.warn('[loadDict] Corrupt data for key', key, '- returning default');
    return defaultDict;
  }
}

/**
 * Merge `updates` into the stored dict (creates if missing).
 * @param {string} key
 * @param {Object} updates   – partial object to merge
 * @returns {Object} the new full dict
 */
function updateDict(key, updates) {
  if (typeof key !== 'string' || key === '') {
    console.error('[updateDict] key must be a non-empty string');
    return {};
  }
  if (!updates || typeof updates !== 'object') {
    console.warn('[updateDict] updates must be a plain object');
    return loadDict(key);
  }

  const current = loadDict(key, {});
  const merged = { ...current, ...updates };

  // Optional: deep merge for nested objects
  // Object.keys(updates).forEach(k => {
  //   if (updates[k] && typeof updates[k] === 'object' && !Array.isArray(updates[k])) {
  //     merged[k] = { ...current[k], ...updates[k] };
  //   } else {
  //     merged[k] = updates[k];
  //   }
  // });

  saveDict(key, merged);
  return merged;
}

/* --------------------------------------------------------------
   Export for different environments
   -------------------------------------------------------------- */
if (typeof module !== 'undefined' && module.exports) {
  // Node / CommonJS
  module.exports = { saveDict, loadDict, updateDict };
} else if (typeof window !== 'undefined') {
  // Browser global
  window.localDict = { saveDict, loadDict, updateDict };
}